１日目　バネダンパでつながれた質点の運動をシミュレーションしよう

# 注意事項
本資料をもとに授業を進めます．
本資料に従ってプログラミングをおこない，課題と問について解いてください．（応用課題については，すべての課題を終えた人だけ解いてください．基本的には課題を解いてもらえれば合格です．）
課題の解答は，レポートにまとめて提出していただきます．詳細は[ReadMe](https://github.com/amby-1/sogoenshu_2024/blob/main/README.md)をよく読んで下さい．

# 概要
スライドを用いて説明予定．

# バネダンパ系の運動シミュレーション
練習問題として，バネでつるされた質点の運動を数値的にシミュレーションしながら，これまで学んだ微分方程式の数値解法を復習する．

## 問題設定
図のように重力下(重力加速度: $g$)で天井から質点（質量: $m$）が線形バネ(バネ定数: $k$)とダンパ(ダンパ定数: $c$)で釣られているシステムを考える．
この時，バネのつり合いの位置を原点として，鉛直上向き方向を正とする座標系を定義し，質点の位置を $x$と表す．バネに重りを付けなかった際（自然長時）のバネ先端の位置を $x_n = mg/k$とする．
さらに，質点には任意の外力 $u$も及ぼされるものとする（実際には接触なく外力を与えるのは難しいが，磁気等を使って外力を非接触で制御できると考えることとする）．

<img src="Figs/model1.png" width="300" alt="バネ質点モデル">

このとき，質点に対して時刻 $t=0$で初期位置と速度 $(x_0, \dot{x}_0)$を与えた際に，質点の運動がどのように時間発展するかを数値計算で確かめる．

## 運動方程式の導出
この質点の運動方程式は，ニュートンの運動方程式の導出方法で簡単に導出することができるが，ここではオイラーラグランジュの運動方程式を使った導出法を復習する．
まず，システムの一般化座標 $q$を定義する必要がある．ここでは，質点の位置 $x$を一般化座標 $q$として定義する．この時，ラグランジアン $L = T - V$（ $T$: 運動エネルギー, $V$: ポテンシャルエネルギー）は，以下のようにかける．
$$L = \frac{1}{2} m \dot{q}^2 - m g q - \frac{1}{2} k {(x_n - q)}^2$$
また，システムの散逸関数 $D$は，ダンパによる抵抗力を考えて以下でかける．
$$D = \frac{1}{2} c \dot{q}^2 $$
散逸関数は授業で扱われていないかもしれない．散逸関数(スカラー)は，速度のみに依存する抵抗力 $f_i$に対して， $f_i = - \frac{\partial D}{\partial \dot{q_i}}$と定義される( $i$は一般化座標 $q$の要素に対応する)．
もし，システムが，ポテンシャルや散逸関数以外に一般化力を持たなければ，全エネルギー $E$の時間発展は $\frac{dE}{dt} = - D$とかける．つまり，散逸関数の物理的意味は，単位時間あたりに抵抗力により失うエネルギーを表している．

つぎに，このシステムの一般化力 $Q$は，質点にかかる外力である $u$と表すことができる．
以上から， $q_i$に対するオイラーラグランジュ方程式
$$\frac{d}{dt} \frac{\partial L}{\partial \dot{q}_i} - \frac{\partial L}{\partial q_i} = - \frac{\partial D}{\partial \dot{q}_i} + Q_i $$
を用いることで，このシステムの運動方程式は，
$$m \ddot x + c \dot{x} + k {x} = u$$
と導出することができる．

>**Note**
>問1 上記を実際に計算して確認せよ

## 運動方程式の数値解法
多くの場合，運動シミュレーションは微分方程式（運動方程式）を数値的に解くことに帰着される．
今回の問題では， $u$が特定の関数の場合（例えば $u$が時間に依存しない場合など）には解析的に解くことができる（厳密解が導出できる）．
しかし， $u$が任意の時間関数になった場合には，解析的な解を求めるのは難しい．
ここでは，２種類の数値解法を用いて，この運動方程式（微分方程式）の時間発展を計算する．

### オイラー法
微分方程式
$$\dot{x} = f(t, x)$$
が与えられた時に，微小時間ステップ $\Delta t$を設定し，時刻 $t+\Delta t$の状態 $x$を
$$x(t+\Delta t) = x(t) + f(t, x)  \Delta t$$
として近似計算する方法．前ステップの値に，時間変化に対する傾き $f(t, x)$ と 時間ステップ $\Delta t$　をかけたものを加えていく計算となっている．
実装は非常に簡単だが，誤差が蓄積しやすいデメリットがある．

### ルンゲクッタ(4次)法
オイラー法はシステムの挙動を点 $(x(t); t)$において線形近似し， $x(t + \Delta t)$ の値を求めたが，テイラー展開を用いるとより詳細な近似が可能になる．
ルンゲクッタ法（4次）は， $x(t+\Delta t)$の4次の項までのテイラー展開と結果が一致するようにした方法である．
テイラー展開するには， $x$の高次の時間微分（ $f(t,x)$の高次時間微分）が必要になるが，それを用いることなく $f(t,x)$のみを使って4次の近似を可能にしたのがルンゲクッタ法である．
詳細には踏み込まないが，計算式は以下である．
$$x(t + \Delta t) = x(t) + \frac{k_1 + 2k_2 + 2k_3 + k_4}{6} \Delta t $$
なお，
```math
k_1 = f(t, \, x(t)), \:   k_2 = f(t + \Delta t /2, \, x(t) + k_1 \Delta t /2) , \: k_3 = f(t + \Delta t /2, \, x(t) + k_2 \Delta t /2) ,  \: k_4 = f(t + \Delta t, \, x(t) + k_3 \Delta t)
```
それほど複雑でない計算で，4次の精度を得ることができる．
そのため，ロボット等のシミュレーションでは良く用いられる数値計算法である．

## プログラムの実装
上記2つの数値解法を用いて質点の運動の時間発展を求めるが，システムの運動方程式
$$m \ddot x + c \dot{x} + k {x} = u$$ 
は2階の微分方程式であり，上記で議論した1階の微分方程式に変換する必要がある．

制御工学で学んだように，2階の微分方程式は変数をあらたに増やすことで，1階の微分方程式にできる．本システムの場合は， $y = \dot x$ なる変数を増やすことによって，以下の1階の微分方程式に帰着できる．
```math
\frac{d}{dt}
\left[
\begin{matrix}
x \\ 
y
\end{matrix}
\right]
= 
\left[
\begin{matrix}
y \\ 
(- c \dot{x} - k {x} + u ) /  m 
\end{matrix}
\right]
``` 
なお，微分方程式で微分される変数（この場合は $(x, y)$）を，制御ではシステムの状態変数と呼んでいた．

>**Important**
>課題1 オイラー法とルンゲクッタ法を用いて，運動方程式を数値計算するプログラムを書け．
>なお，外力uは時間のみに依存する関数としてプログラム内で定義しておいてください．
>また，以下で指定する数値例で運動方程式を解け．


### 物理パラメタ等
作成したプログラムを使って，以下の物理パラメタの下，ダンパ係数 $c$を様々に変化させて，システムの応答を確認してみてください． $u(t)=0$としてください．
| 変数 | 値   |   変数 | 値 |
| ------- | --------- | --------- | ------- |
| $m$   | 1 [kg]     |     $x(0)$ |  1 [m]   |
| $k$   | 10 [N/m]    |     $\dot{x}(0)$ |  0 [m]   |
| 刻み幅 $dt$   | 0.01 [s]     |     シミュレ時間 $T$ | 10 [s]   |

ダンパ係数を４種類変化させて（0, 3, 6, 9）， $x$の時間変化のグラフをルンゲクッタ法を用いて作ってください．

<img src="Figs/kadai1.png" width="400" alt="課題１">

これまでの授業で培ってきた直観とあっているでしょうか？

### 課題1のヒント 
 C言語 の場合を例としてプログラムの構築例を示す．TODOと書かれたところは自分で書いてください．(C++の例は最後の方に載せています．)
（特にこのように書けという指示ではないため，プログラミングに慣れた方は自由にコーディングしてください．）

### C言語の例
分かりやすくするために，グローバル変数を用いて実装している．
```c
#include <stdio.h>
#include <math.h>
#include <stdbool.h>

// 定数の設定
const double g = 9.8;  // 重力加速度 [m/s^2]

// グローバル変数の定義
// 物理定数
double m;        // 質量 [kg]
double k;        // バネ定数 [N/m]   
double c;        // ダンパ係数 [Ns/m]  
// 状態量
double x;        // 位置 [m]
double dx;       // 速度 [m/s]
// 時間
double t;     // 時間 [s]

// 初期値設定
void set_iniVal(double x_, double dx_){
    t = 0;
    x = x_;
    dx = dx_;
}

// 制御入力の計算式
double func_u(double t){
    return 0.;
}

// 微分方程式
//  ベクトル関数をそれぞれ要素に分けて記述
// dx = f_1 (t, x, dx) 
double func_dx(double t_, double x_, double dx_){
    // TODO ここに微分方程式の右辺を書く
    return TODO; 
}
 
// ddx = f_2 (t, x, dx)
double func_ddx(double t_, double x_, double dx_){
    // TODO ここに微分方程式の右辺を書く
    return TODO;
}

// 1ステップ計算させる
// euler法
void step_euler(double dt) {
    // TODO dt 後の状態(x, dx) と tを計算
    dx =  0; // TODO 
    x  =  0; // TODO 
    t += dt; 
}

// 時間を１ステップ進める
// Runge kutta法
void step_rk4(double dt) {
    // TODO :: dt 後の状態(x, dx) と tを計算 
}

int main() {
    // パラメータの設定
    m = 1.;           // 質量 [kg]
    k = 10.;           // バネ定数 [N/m]   
    c = 0.;           // ダンパ係数 [Ns/m]  

    double ini_x = 1.;        // 初期位置 [m]
    double ini_dx = 0.;       // 初期速度 [m/s]
    
    double dt = 0.01;            // タイムステップ [s]
    double total_time = 10.;    // 総計算時間 [s]

    set_iniVal(ini_x, ini_dx);

    FILE *ofs = fopen("data_runge_c.dat", "w");  // ファイルを書き込みモードで開く

    for (double time = 0.; time < total_time - dt/2.; time += dt) {
        fprintf(ofs, "%f, %f, %f\n",  t, x, dx); // 毎回ログを取る
        step_rk4(dt); // euler か runge によって呼ぶ関数を変える
    }
    fprintf(ofs, "%f, %f, %f\n",  t, x, dx); // 最後のログを取る

    fclose(ofs);  // ファイルを閉じる

    printf("Calculation completed and data has been saved");

    return 0;
}
```

### Gnuplotの例
得られた結果の時間データは，グラフにプロットしないと良く分からない．グラフ作成には様々なツールが存在し，何をつかっても構わない．
ここでは，gnuplotを使った場合のプログラムの一例を示す．（gnuplotに慣れていない方は，WEBサイトを検索すると良い．例えば[阪大サイト](https://www.library.osaka-u.ac.jp/doc/LS_20190111_gnuplot.pdf)もある）

本スクリプトを `plot.gp` のように，`.gp` 拡張子を付けて保存し，gnuplotで実行（右クリックで `プログラムから開く` ，`wgnuplot.exe` を選ぶ．既定アプリにすれば，以後ダブルクリックするだけで実行できる）すれば良い．

```plaintext
# プロットの設定
set title "Spring Mass Model Time Evolution"
set xlabel "Time [s]"
set ylabel "Position [m]"
set grid

# データのプロット
plot "data_test.dat" using 1:2 with lines title "x(t) from Euler"
replot "data_runge.dat" using 1:2 with lines title "x(t) from RK4"


# グラフを保存
set terminal pngcairo
set output "test_plot.png"
replot

# プロットを画面に表示
pause mouse
```

## プログラムの妥当性の検証
実装したプログラムがうまく動いているか，バグがないかを調べる必要がある．
微分方程式の解析解は求まらない場合がほとんどのため，この検証は難しい場合が多い．
しかし，今回に限っては， $u=0, c=0$の時には解析的に解を導出可能であり，解析解と比較することでプログラムを検証する．

$u=0, c=0$の場合の一般解は，以下のように求めることができる．
$$x = a \cos (\omega t + \phi)$$ 
なお， $\omega$は， $m,k$を用いて表すことができ， $a, \phi$は初期状態に応じて決まる量である．

>**Note**
>問2 上記を実際に計算して，シミュレーション条件での解析解を求めよ．

>**Warning**
>応用課題1 ダンパが存在する場合でも解析解は求めることができる．
>解析解を求め，シミュレーションと比較してみよ．

<!-- omega = \sqrt(k / m) , a = 1, phi = 0 -->

プログラムの妥当性を確認する方法は様々なやり方が考えられる．
一番簡単なやり方は，解析解と数値計算結果の時間発展を実際にプロットして，数値計算結果が解析解（真値）からずれないことを定性的に確認する事である．

>**Important**
>課題2 u=0, c=0, シミュレーション時間 50[s], dt = 0.2[s]（それ以外は課題１と同じ条件）において，
>位置xの時間変化を，解析解（真値）とオイラー法，ルンゲクッタ法とで比較せよ．
>また，相図（横軸縦軸を状態空間の(x,y)にしたもの）をプロットし，同様に確かめよ．結果について誤差の観点から考察せよ．

しかし，このやり方では，定性的にプログラムがあっていそうなことは確かめられても，定量的に妥当なのかは良く分からない．
真値とのずれが，数値計算で想定される誤差程度に収まっているのか評価できていない．

そこで，ここでは以下のように，位置に対して１[s]後の絶対誤差 $e$を定義し，この誤差が $dt$を変えた時にどのように小さくなっていくかをもとに，プログラムの妥当性を定量的に評価する．
```math
e_{\Delta t} = | x_{\Delta t}(1) - \hat{x}(1) |
``` 
なお， ${x}_{\Delta t}$は，オイラー法またはルンゲクッタ法で $\Delta t$刻みで計算した位置であり， 
 $\hat{x}$は真値であるとする．

>**Important**
>課題3 絶対誤差 e が，dt に対してどのように変化するかを両対数グラフで示せ（オイラー法とルンゲクッタ法それぞれについて）．
>なお，シミュレーションの初期値や物理パラメタ等は，課題1と同じものをもちいて構わない．(なお，u=c=0)．
>オイラー法やルンゲクッタ法の計算精度（理論）をもとに，プログラムが妥当であるかどうかについて考察してみよ．
>また，dtを小さくしてもeの精度が良くならない状況があった場合が，その理由も考察せよ．

ヒント：　これは少し難しい課題である．正確なプログラムがかけていないと，ルンゲクッタ法が理論通りの高精度にならない．
ルンゲクッタ法の精度がオイラー法程度しか出ない場合，以下の可能性も疑ってください．
評価をおこなう時刻（今回は  $t=1$ [s]）がプログラム上で正確か？（サンプルプログラムは，終了時間について雑に作ってますので注意してください）．
また，時刻の精度は $\Delta t$の取り方（評価する時刻が $\Delta t$で割り切れるか？）にも依存しますので，注意してください．

## 強制振動の分析
$c \neq 0$ の場合，時間とともに振動はなくなってしまうが，
 $u(t) = \sin ( \hat{\omega} t)$ のように，周期外力を加えたものは振動を続けることが知られている（強制振動）．そして，強制入力項の振動数がある特定の値になった際に，振動の振幅が大きくなる（共鳴）することが知られている．

>**Warning**
>応用課題2 cがゼロでない場合に，上記を実際に確かめてみよ．
>様々な周波数で振動を加えて，時間とともに定常振動になるかを確認せよ．
>また，周波数に応じて定常振動の振幅がどのように変化するかを調べてみよ．
>（横軸周波数，縦軸振幅としたグラフを書いてみるとよい）

### C++言語の例
C＋＋言語でのプログラム例を示す．
```cpp :example1.cpp
#include <iostream>
#include <cmath>
#include <vector>
#include <fstream>

// 定数の設定
const double g = 9.8;  // 重力加速度 [m/s^2]

// クラスの定義
//  運動方程式の状態量や物理パラメタを管理しており，step_?? 関数を呼び出すことで状態量の時間を１ステップ(dt)進める機能を提供する
class Spring_mass {
private: 
    // メンバ変数
    double m;        // 質量 [kg]
    double k;        // バネ定数 [N/m]   
    double c;        // ダンパ係数 [Ns/m]  
    double x;        // 位置 [m]  　　＊時間とともに変化します．
    double dx;       // 速度 [m/s]　　＊時間とともに変化　
    double t;     // 時間 [s]　＊時間とともに変化

public:
    // コンストラクタ -- 変数を初期化する
    //  初期時間はゼロとしている
    //   m(m_) は，メンバ変数 m を m_ で初期化するという文法です．他も同様
    Spring_mass(double m_, double k_, double c_, double x_, double dx_) : m(m_), k(k_), c(c_), x(x_), dx(dx_), t(0.){}

    // 制御入力の計算式
    double func_u(double t){
        return 0.;
    }

    // 時間発展の微分方程式
    double func_dx(double t_, double x_, double dx_){
        // ここにdx/dt の時間発展の式を書く (dx/dt)
        //  微分方程式 dx/dt = f_1(t, x, dx) の右辺を書く
        return TODO; 
    }
    double func_ddx(double t_, double x_, double dx_){
        // ここにddx / ddt 時間発展の式を書く (dy/dt)
        //  微分方程式 ddx/dt = f_2(t, x, dx) の右辺を書く
        return TODO;
    }

    // 1ステップ計算させる
    // euler法
    void step_euler(double dt) {
        TODO
    }

    // Runge kutta法
    void step_rk4(double dt) {
        TODO
    }

    // データを取り出す
    double get_x(){
        return x;
    }
    double get_dx(){
        return dx;
    }
    double get_t(){
        return t;
    }
    double get_u(){
        return func_u(t);
    }
};

int main() {
    // パラメータの設定
    double m = 1.;           // 質量 [kg]
    double k = 10.;           // バネ定数 [N/m]   
    double c = 1.;           // ダンパ係数 [Ns/m]  

    double ini_x = 1.;        // 初期位置 [m]
    double ini_dx = 0.;       // 初期速度 [m/s]
    
    double dt = 0.01;            // タイムステップ [s]
    double total_time = 10.0;    // 総計算時間 [s]

    Spring_mass spring_mass(m, k, c, ini_x, ini_dx); // 上で作ったクラスを呼び出す

    std::ofstream ofs("data_runge.dat"); // データを保存するためのファイルを開く

    for (double t = 0.; t < total_time - dt/2.; t += dt) { // 毎ステップ，微分方程式を数値的に解く
        ofs << spring_mass.get_t() << ", " << spring_mass.get_x()  << ", " << spring_mass.get_dx() << std::endl;  // 時間と状態量をクラスから読み出し，ファイルに保存  　ファイルへの保存の仕方はC言語よりも直観的だと思います． std::endl で改行されます．
        spring_mass.step_rk4(dt); // ルンゲクッタ法のstep関数を呼び出して，時間と状態量を次のステップに進める
    }
    ofs << spring_mass.get_t() << ", " << spring_mass.get_x()  << ", " << spring_mass.get_dx() << std::endl; // 最後のデータ出力

    ofs.close();  // ファイルを閉じる

    std::cout << "Calculation completed and data has been saved -- sim duration is " << total_time << " [s]" << std::endl; // こんな感じでコンソールにメッセージを出せます．デバッグに活用してください．

    return 0;
}

```
簡単にサンプルプログラムの説明を行う．サンプルプログラムでは，クラス`Spring_mass`を用いて運動方程式に関わる変数の管理と，シミュレーションのための関数を機能として提供している．
クラスになじみがないかもしれない．詳細は参考文献に譲る．
誤解を恐れず簡単に述べると，クラスは「関数（メンバ関数）と変数（メンバ変数）を含む 構造体`struct`であり，メンバ関数を通して自在にメンバ変数を変更できる」程度に考えてもらえれば良い．

このクラスは，メンバ変数として運動方程式の物理変数，状態量，時間を保持している．
```cpp
private: 
    // メンバ変数
    double m;        // 質量 [kg]
    double k;        // バネ定数 [N/m]   
    double c;        // ダンパ係数 [Ns/m]  
    double x;        // 位置 [m]  　　＊時間とともに変化します．
    double dx;       // 速度 [m/s]　　＊時間とともに変化　
    double t;     // 時間 [s]　＊時間とともに変化
```
`private:`の記載は，クラス内部のメンバ関数でしか変数にアクセスできないという意味である（状態変数は運動方程式のみで決まるものなので，`main`など外から勝手に触られないように隠ぺいしている程度の理解で良い）．

本クラスはメンバ関数として多くの関数を持っている．最初の関数のようなものは，コンストラクタと呼ばれ，クラスを定義する際に必ず実行されるものである．ここでは，物理変数や状態変数の初期化を行っている．
```cpp
Spring_mass(double m_, double k_, double c_, double x_, double dx_) : m(m_), k(k_), c(c_), x(x_), dx(dx_), t(0.){}
```

以下の関数は，各状態変数の微分方程式 $\dot x = f_x(t, x, y), \dot y = f_y(t, x, y)$ ( $y$はプログラム内のdx)の右辺に対応している，
```cpp
double func_dx(double t_, double x_, double dx_){
    // ここにdx/dt の時間発展の式を書く (dx/dt)
    return TODO; 
}
double func_ddx(double t_, double x_, double dx_){
    // ここにddx / ddt 時間発展の式を書く (dy/dt)
    return TODO;
}
```

以下の関数`step_????(double dt)`で，微小時間 $\Delta t$ (dt) 後の状態変数の時間発展を，上記関数`func_???()`を用いて計算している．変数`x, dx, t`の値が更新されるはずである． 
```cpp
// euler法
void step_euler(double dt) {
    TODO
}
// Runge kutta法
void step_rk4(double dt) {
    TODO
}
```

最後に，main関数からクラス内のメンバ変数を取り出すための関数が定義されている(`get_?()`)


次に，main関数内部の説明を行う．
```cpp
Spring_mass spring_mass(m, k, c, ini_x, ini_dx); // 上で作ったクラスを呼び出す
```
上記コマンドによって，上記のクラス`Spring_mass`を実体`spring_mass`として定義する．なお，コンストラクタを同時に呼び出して初期化している．

次に，データを保存するためのファイルを作成し，
```cpp
std::ofstream ofs("data_runge.dat"); // データを保存するためのファイルを開く
```

`for`ループを用いて，微小時間ごとに`spring_mass`クラスの`step_??()`関数を呼び出し，クラス内の状態変数を更新する．また，ファイルへと状態変数を保存する．
```cpp
for (double t = 0.; t < total_time -dt/2.; t += dt) { // 毎ステップ，微分方程式を数値的に解く
    ofs << spring_mass.get_t() << ", " << spring_mass.get_x()  << ", " << spring_mass.get_dx() << std::endl;  
    spring_mass.step_rk4(dt); // ルンゲクッタ法のstep関数を呼び出して，時間と状態量を次のステップに進める
}
```
以上が大まかなプログラムの流れである．

# 参考資料
- C＋＋言語に関する資料等
  - WEBサイト https://programming.pc-note.net/cpp/class2.html
- 数値計算法に関する資料等
  - WEBサイト「東京大学工学部 精密工学科 プログラミング応用 I・ II」 http://www.den.t.u-tokyo.ac.jp/ad_prog/ode/
    
